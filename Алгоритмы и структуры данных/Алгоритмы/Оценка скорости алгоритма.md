### **Big-O нотация**

Big-O нотация описывает, как алгоритм ведет себя при увеличении входных данных (n).
#### Формальное определение:

O(f(n)) — верхняя граница времени выполнения алгоритма, где f(n) — функция роста.  
Мы анализируем **худший сценарий** работы алгоритма.

---
**Типы временной сложности**

| Нотация   | Описание                                                                         | Пример алгоритма                                                          |
| --------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| O(1)      | **Константная сложность**. Время не зависит от размера входных данных.           | Доступ к элементу по индексу в массиве.                                   |
| O(log⁡n)  | **Логарифмическая сложность**. Каждый шаг уменьшает проблему вдвое.              | Бинарный поиск.                                                           |
| O(n)      | **Линейная сложность**. Время пропорционально размеру данных.                    | Линейный поиск.                                                           |
| O(nlog⁡n) | **Квазилинейная сложность**. Работает быстрее, чем O(n2), но медленнее, чем O(n) | Быстрая сортировка, сортировка слиянием.                                  |
| O(n2)     | **Квадратичная сложность**. Каждая операция требует прохода по всем данным.      | Сортировка вставками, пузырьковая сортировка.                             |
| O(2n)     | **Экспоненциальная сложность**. Время растет очень быстро с увеличением nnn.     | Решение задач методом перебора.                                           |
| O(n!)     | **Факториальная сложность**. Катастрофически неэффективна.                       | Задачи с перестановками, например, решение задачи коммивояжера перебором. |
___

**Примеры**

1. **O(1) — Константная сложность**
	Доступ к элементу массива по индексу:
```Javascript
const array = [10, 20, 30, 40];
console.log(array[2]); // Выполняется за O(1)
```
2. **O(n) — Линейная сложность**
	Итерация по массиву:
```Javascript
const array = [1, 2, 3, 4, 5];
let sum = 0;

for (let i = 0; i < array.length; i++) {
  sum += array[i]; // Выполняется n раз
}

console.log(sum); // O(n)
```
3.  **O(n2) — Квадратичная сложность**
	Вложенные циклы:
```Javascript
const array = [1, 2, 3];

for (let i = 0; i < array.length; i++) {
  for (let j = 0; j < array.length; j++) {
    console.log(array[i], array[j]); // Выполняется n * n раз
  }
}
// O(n^2)
```
4. **O(log⁡n) — Логарифмическая сложность**
	Пример с бинарным поиском: [[Бинарный поиск|Подробнее про Бинарный поиск]]
```Javascript
// Найти число 7 из отсортированного массива и вернуть его индекс

function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return -1;
}

const sortedArray = [1, 3, 5, 7, 9, 11, 13];
const target = 7;
const result = binarySearch(sortedArray, target);

if (result !== -1) {
  console.log(`Элемент найден на индексе: ${result}`);
} else {
  console.log("Элемент не найден");
}
```